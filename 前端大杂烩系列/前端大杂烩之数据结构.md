#### 1. 基本数据结构  

&emsp;&emsp;**—数组**  

&emsp;&emsp;**—列表**   

&emsp;&emsp;数组是基础，然后为数组封装好一个List构造函数，增加长度、插入、删除、索引、遍历等工具接口，这样就构造了一个列表。  

&emsp;&emsp;**—栈**  

&emsp;&emsp;具有后进先出的特点，是一种高效的列表，只对栈顶的数据进行添加和删除。  

&emsp;&emsp;**—队列**  

&emsp;&emsp;具有先进先出的特点，是只能在队首取出或者删除元素，在队尾插入元素的列表。  

&emsp;&emsp;**—链表**  

&emsp;&emsp;如c++和java这样的语言，数组是静态的，效率很高，长度固定，但是，当数组满了之后，再向其中增加数据就非常困难了。js中的数据是个对象，数组是动态的，没有了长度的限制，但是，数组的索引下标需要在js语言内部转换为js对象的属性名，因此效率打了折扣。因此，在实际应用中，除了有随机访问的需求之外，其他情况都可以用链表替换数组。

&emsp;&emsp;**—字典**  

&emsp;&emsp;js对象具有字典的功能，可以用object来模拟字典的实现。  

&emsp;&emsp;**—散列**    

&emsp;&emsp;散列使用的数据结构叫做散列表。在散列表上插入、删除和取用数据都非常快，但是对于查找操作来说却效率低下。散列表是将数据映射到散列上，但是，有的时候会产生数据碰撞，这个时候就需要用开链法、线性探测法进行碰撞的解决。  

&emsp;&emsp;**—集合**  

&emsp;&emsp;集合是一种包含不同元素的数据结构。集合中的元素称为成员。集合的两个最重要特性是：一是集合中的成员是无序的，二是集合中不允许相同成员存在。  

&emsp;&emsp;**—树**   

&emsp;&emsp;树是非线性，分层存储的数据结构。可用来存储文件系统或者有序列表。树都有一个根节点，如果一个节点下边有其他节点，则该节点称为它们的父节点，这些节点为子节点。  

#### 2. 八大经典排序算法原理  

&emsp;&emsp;**冒泡排序**  

&emsp;&emsp;原理：  

&emsp;&emsp;&emsp;&emsp;第一轮从下标为 0 到 n-1 的元素。即（0，n-1），依次比较相邻两个元素，把最大（或最小）的数移动到最右边位置，即下标为 n-1处；  
&emsp;&emsp;&emsp;&emsp;第二轮再从下标为 0 到 n-2 的元素。即（0，n-2），依次比较相邻两个元素，把最大（或最小）的数移动到最右边-1 位置，即下标为 n-2 处；  
&emsp;&emsp;&emsp;&emsp;一值重复n轮即可达到排序效果。  

&emsp;&emsp;**插入排序**  

&emsp;&emsp;原理： 

&emsp;&emsp;&emsp;&emsp;每步将一个待排序序列按数据大小插到前面已经排序的序列中的适当位置，直到全部数据插入完毕为止。   

&emsp;&emsp;**选择排序**  

&emsp;&emsp;原理：  

&emsp;&emsp;&emsp;&emsp;从未排序的元素中选出最小值(最大值)放在已排序元素的后面。  

&emsp;&emsp;&emsp;&emsp;第一轮从下标为 1 到下标为 n-1 的元素中选取最小值，若小于第一个数，则交换。  

&emsp;&emsp;&emsp;&emsp;第二轮从下标为 2 到下标为 n-1 的元素中选取最小值，若小于第二个数，则交换。  

&emsp;&emsp;&emsp;&emsp;依次类推下去......  

&emsp;&emsp;**希尔排序**  

&emsp;&emsp;原理：  

&emsp;&emsp;&emsp;&emsp;其原理是将序列分割成若干子序列（由相隔某个增量的元素组成的），分别进行直接插入排序；接着依次缩小增量继续进行排序，待整个序列基本有序时，再对全体元素进行插入排序。  

&emsp;&emsp;**堆排序**  

&emsp;&emsp;原理：  

&emsp;&emsp;&emsp;&emsp;堆排序其实就是将序列建立堆之后，将堆顶元素和堆尾第 n-i 位置元素交换，再做 (0,n-i) 堆调整；  

&emsp;&emsp;&emsp;&emsp;循环 n 次之后，即完成排序;  

&emsp;&emsp;&emsp;&emsp;由于每次都是将最小的数据并入到后面的有序区间，故操作完成后整个数组就有序了。有点类似于直接选择排序。  

&emsp;&emsp;**归并排序**  

&emsp;&emsp;原理：   

&emsp;&emsp;&emsp;&emsp;归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。  

&emsp;&emsp;**快速排序**  

&emsp;&emsp;原理：   

&emsp;&emsp;&emsp;&emsp;先从序列中选取一个数做为基准数；  

&emsp;&emsp;&emsp;&emsp;再遍历原序列，大于这个基准数的放在右边，小于这个基准数的方法在左边；  

&emsp;&emsp;&emsp;&emsp;再对左右两边分别进行上述两个步骤，直到各个区间只有一个数。  

&emsp;&emsp;**二分排序**  

&emsp;&emsp;原理：   

&emsp;&emsp;&emsp;&emsp;二分查找排序是改进的插入排序，不同之处在于，在有序区间查找新元素插入位置时，为了减少比较次数提高效率，采用二分查找算法进行插入位置的确定。  

#### 3. 费波拉切数列的实现方法

&emsp;&emsp;**递归方法**  

    function digui(n){  
        if(n==1||n==2){  
            return 1;  
        }  
        return digui(n-1)+digui(n-2);  
    }    
    
&emsp;&emsp;**非递归方法1**  

    function feidg(n){  
        var res = [1,1];  
        if(n == 1 || n == 2){  
            return 1;  
        }        
        for(var i=2;i<n;i++){  
            res[i] = res[i-1] + res[i-2];  
        }  
        return res[n-1];  
    }    

&emsp;&emsp;**非递归方法2**   

    function feidg(n){  
        var a,b,res;  
        a = b = 1;  
        for(var i=3;i<=n;i++){  
            res = a + b;  
            a = b;  
            b = res;  
        }  
        return res;  
    }  