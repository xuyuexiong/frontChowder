#### 1. 什么是MVVM，MVC，MVP  

&emsp;**MVC**    

&emsp;&emsp;Model-View-Controller（模型-视图-控制器）：用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。它强制性的使应用程序的输入、处理和输出分开。  

&emsp;**MVP**  

&emsp;&emsp;Model-View-Presenter：是从经典的模式MVC演变而来。它们的基本思想有相通的地方，Controller/Presenter负责逻辑的处理，Model提供数据，View负责显示。  
&emsp;&emsp;作为一种新的模式，MVP与MVC有着一个重大的区别：在MVP中View并不直接使用Model，它们之间的通信是通过Presenter (MVC中的Controller)来进行的，所有的交互都发生在Presenter内部，而在MVC中View会从直接Model中读取数据而不是通过 Controller。  

&emsp;**MVVM**  

&emsp;&emsp;Model-View-ViewModel：和MVC模式一样，主要目的是分离视图（View）和模型（Model）；在概念上是真正将页面与数据逻辑分离的模式，在开发方式上，它是真正将前台代码开发者（JS+HTML）与后台代码开发者分离的模式（asp,asp.net,php,jsp）。  

#### 2. Vue和Angular的双向数据绑定原理  

&emsp;&emsp;Vue和Angular实现双向数据绑定的原理就是利用了Object.defineProperty() 这个方法重新定义了对象获取属性值(get)和设置属性值(set)的操作来实现的。   
&emsp;&emsp;实现数据的双向绑定，首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者Watcher看是否需要更新。因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。以下3个步骤，实现数据的双向绑定：  

&emsp;&emsp;1.实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。

&emsp;&emsp;2.实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。

&emsp;&emsp;3.实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。

#### 3. React生命周期    

&emsp;&emsp;一个React组件的生命周期分为三个部分：挂载期（Mounting）、存在更新期（Updating）和销毁时（Unmounting）。  

&emsp;&emsp;**一、Mounting**  

&emsp;&emsp;&emsp;&emsp;首次调用组件时，有以下方法会被调用：  

&emsp;&emsp;&emsp;&emsp;1、getDefaultProps  

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;这个方法是用来设置组件默认的props，组件生命周期只会调用一次。但是只适合React.createClass直接创建的组件。  

&emsp;&emsp;&emsp;&emsp;2、getInitialState  

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;设置state初始值。  

&emsp;&emsp;&emsp;&emsp;3、componentWillMount  

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;该方法会在组件首次渲染之前调用，这个是在render方法调用前可修改state的最后一次机会。这个方法很少用到。  

&emsp;&emsp;&emsp;&emsp;4、render  

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;JSX通过这里，解析成对应的虚拟DOM，渲染成最终效果。  

&emsp;&emsp;&emsp;&emsp;5、componentDidMount  

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;这个方法在首次真实的DOM渲染后调用（仅此一次）当我们需要访问真实的DOM时，这个方法就经常用到。  

&emsp;&emsp;**二、Updating**  

&emsp;&emsp;&emsp;&emsp;实例化后，当props或者state发生变化时，下面方法依次被调用：  

&emsp;&emsp;&emsp;&emsp;1、componentWillReceiveProps  

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;每当我们通过父组件更新子组件props时（这个也是唯一途径），这个方法就会被调用。  

&emsp;&emsp;&emsp;&emsp;2、shouldComponentUpdate  

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;字面意思，是否应该更新组件，默认返回true。当返回false时，后期函数就不会调用，组件不会在次渲染。  

&emsp;&emsp;&emsp;&emsp;3、componentWillUpdate  

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;字面意思组件将会更新，props和state改变后必调用。  

&emsp;&emsp;&emsp;&emsp;4、render  

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;跟实例化时的render一样。  

&emsp;&emsp;&emsp;&emsp;5、componentDidUpdate  

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;这个方法在更新真实的DOM成功后调用，当我们需要访问真实的DOM时，这个方法就也经常用到。  

&emsp;&emsp;**二、Unmounting**   

&emsp;&emsp;&emsp;&emsp;销毁阶段，只有一个函数被调用：  

&emsp;&emsp;&emsp;&emsp;componentWillUnmount  

&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;每当组件使用完成，这个组件就必须从DOM中销毁，此时该方法就会被调用。当我们在组件中使用了setInterval，那我们就需要在这个方法中调用clearTimeout。